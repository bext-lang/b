<!DOCTYPE html>
<html>
  <head>
    <title>B Program</title>
  </head>
  <body>
    <h2>Console:</h2>
    <pre id="log"></pre>
    <script>
"use strict";
class Memory {
    #globals = {};
    #stacks = [];
    #stack_pointer;
    #heap_base;
    #memory;
    #view;

    constructor(initialized_data, globals, stack_size) {
        for(let i = 0; i < globals.length; i++)
            this.#globals[globals[i]] = initialized_data.length + i*8;

        this.#stack_pointer = initialized_data.length + globals.length*8;
        this.#heap_base = this.#stack_pointer + stack_size;
        this.#memory = new ArrayBuffer(this.#heap_base, { maxByteLength: 2**31-1 });
        this.#view = new DataView(this.#memory);

        this.view(0, initialized_data.length).set(initialized_data);
    }

    view(start, length) {
        return new Uint8Array(
            this.#memory,
            Number(start),
            length ? Number(length) : undefined
        );
    }

    slice(start, length) {
        return this.#memory.slice(
            Number(start),
            length ? Number(start)+Number(length) : undefined
        );
    }

    alloc(size) {
        const ptr = this.#memory.byteLength;
        this.#memory.resize(ptr+Number(size));
        return BigInt(ptr);
    }

    fill(start, byte, size) {
        let bytes = Array(size).fill(Number(byte));
        this.view(start, size).set(bytes);
    }

    get(ptr)                { return this.#view.getBigInt64(Number(ptr),        true); }
    set(ptr, value)         {        this.#view.setBigInt64(Number(ptr), value, true); }
    get_global(name)        { return this.get(this.#globals[name]                   ); }
    set_global(name, value) {        this.set(this.#globals[name], value            ); }
    get_local(index)        { return this.get(this.#stack_pointer - index*8         ); }
    set_local(index, value) {        this.set(this.#stack_pointer - index*8, value  ); }

    push_stack(auto_vars_count) {
        this.#stacks.push(this.#stack_pointer);
        this.#stack_pointer += auto_vars_count*8;
        if(this.#stack_pointer >= this.#heap_base)
            throw new Error("Stack overflow");
    }

    pop_stack() {
        this.#stack_pointer = this.#stacks.pop();
    }
}

// The compile B program
<<<GENERATED>>>

// The B runtime
const log = document.getElementById("log");
let logBuffer = "";
const utf8decoder = new TextDecoder();
function __flush() {
    log.innerText += logBuffer;
    logBuffer = "";
}
function __print_string(s) {
    for (let i = 0; i < s.length; ++i) {
        logBuffer += s[i];
        if (s[i] === '\n') __flush();
    }
}
function putchar(code) {
    __print_string(String.fromCharCode(code));
    return code;
}
function strlen(ptr) {
    return memory.view(ptr).indexOf(0);
}
function isdigit(c) {
    c -= 48n;
    return 0n <= c && c <= 9n;
}
function printf(fmt, ...args) {
    const n = strlen(fmt);
    // TODO: print formatting is not fully implemented
    const bytes = memory.slice(fmt, n);
    const str = utf8decoder.decode(bytes);

    for (let i = 0; i < str.length;) {
        if (str[i] === '%') {
            i += 1;
            if (i >= str.length) throw new Error("Unfinished formating sequence");

            let width = 0;
            while (isdigit(BigInt(str.charCodeAt(i))) && i < str.length) {
                width = width*10 + str.charCodeAt(i) - 48;
                i += 1;
            }

            const prefix = str.slice(i);
            const number_arg = ['lu', 'd'].find((arg) => prefix.startsWith(arg));
            if (number_arg !== undefined) {
                __print_string(Number(args.shift()).toString().padStart(width));
                i += number_arg.length;
            } else if (prefix.startsWith('%')) {
                __print_string('%');
                i += 1;
            } else if (prefix.startsWith('c')) {
                __print_string(String.fromCharCode(args.shift()).padStart(width));
                i += 1;
            } else {
                throw new Error(`Unknown format sequence starts with "${str[i]}"`);
            }
        } else {
            __print_string(str[i]);
            i += 1;
        }
    }

    // TODO: return number of bytes printed
    return BigInt(0);
}
function malloc(size) {
    return memory.alloc(size);
}
function memset(ptr, byte, size) {
    memory.fill(ptr, byte, size);
    return ptr;
}
main();
__flush();
    </script>
  </body>
</html>
